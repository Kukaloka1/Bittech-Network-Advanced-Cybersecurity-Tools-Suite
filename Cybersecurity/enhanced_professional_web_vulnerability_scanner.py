import requests
from bs4 import BeautifulSoup
import dns.resolver
import socket
import ssl
from urllib.parse import urlparse, parse_qs, urljoin
from concurrent.futures import ThreadPoolExecutor, as_completed
import re
import json
import warnings
import nmap
import whois
import subprocess
import time
from packaging import version
import os
import sys
from Wappalyzer import Wappalyzer, WebPage
import shodan

warnings.filterwarnings("ignore", category=requests.packages.urllib3.exceptions.InsecureRequestWarning)

class AdvancedWebVulnerabilityScanner:
    def __init__(self, target_url, shodan_api_key):
        self.target_url = target_url
        self.domain = urlparse(target_url).netloc
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        self.results = {
            "domain_info": {},
            "dns_info": {},
            "whois_info": {},
            "ssl_info": {},
            "headers": {},
            "technologies": [],
            "open_ports": [],
            "vulnerabilities": [],
            "sensitive_files": [],
            "subdomains": [],
            "shodan_info": {},
            "wayback_urls": []
        }
        self.install_nmap()
        self.shodan_api = shodan.Shodan(shodan_api_key)

    def install_nmap(self):
        try:
            subprocess.run(["nmap", "-v"], capture_output=True, text=True)
            print("nmap ya está instalado.")
        except FileNotFoundError:
            print("Instalando nmap...")
            if sys.platform.startswith('darwin'):
                os.system('brew install nmap')
            elif sys.platform.startswith('linux'):
                os.system('sudo apt-get install nmap -y')
            else:
                print("Por favor, instala nmap manualmente desde https://nmap.org/download.html")

    def run_scan(self):
        print(f"Iniciando escaneo avanzado de {self.target_url}")
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [
                executor.submit(self.get_domain_info),
                executor.submit(self.check_dns),
                executor.submit(self.get_whois_info),
                executor.submit(self.check_ssl),
                executor.submit(self.check_headers),
                executor.submit(self.detect_technologies),
                executor.submit(self.scan_ports),
                executor.submit(self.check_common_vulnerabilities),
                executor.submit(self.find_sensitive_files),
                executor.submit(self.discover_subdomains),
                executor.submit(self.get_shodan_info),
                executor.submit(self.get_wayback_urls)
            ]
            for future in as_completed(futures):
                future.result()
        
        self.analyze_results()
        self.print_results()

    def get_domain_info(self):
        try:
            ip = socket.gethostbyname(self.domain)
            self.results["domain_info"]["ip"] = ip
            try:
                hostname, _, _ = socket.gethostbyaddr(ip)
                self.results["domain_info"]["hostname"] = hostname
            except socket.herror:
                self.results["domain_info"]["hostname"] = "No se pudo resolver el nombre de host"
        except socket.gaierror as e:
            self.results["domain_info"]["error"] = f"No se pudo resolver el dominio: {str(e)}"

    def check_dns(self):
        for qtype in ['A', 'AAAA', 'MX', 'NS', 'TXT', 'SOA']:
            try:
                answers = dns.resolver.resolve(self.domain, qtype)
                self.results["dns_info"][qtype] = [str(rdata) for rdata in answers]
            except dns.resolver.NoAnswer:
                self.results["dns_info"][qtype] = "No se encontraron registros"
            except Exception as e:
                self.results["dns_info"][qtype] = f"Error: {str(e)}"

    def get_whois_info(self):
        try:
            w = whois.whois(self.domain)
            self.results["whois_info"] = {
                "registrar": w.registrar,
                "creation_date": str(w.creation_date),
                "expiration_date": str(w.expiration_date),
                "name_servers": w.name_servers
            }
        except Exception as e:
            self.results["whois_info"]["error"] = str(e)

    def check_ssl(self):
        try:
            context = ssl.create_default_context()
            with socket.create_connection((self.domain, 443)) as sock:
                with context.wrap_socket(sock, server_hostname=self.domain) as secure_sock:
                    cert = secure_sock.getpeercert()
                    self.results["ssl_info"] = {
                        "version": secure_sock.version(),
                        "cipher": secure_sock.cipher(),
                        "expiration": cert['notAfter'],
                        "subject": dict(x[0] for x in cert['subject']),
                        "issuer": dict(x[0] for x in cert['issuer'])
                    }
        except Exception as e:
            self.results["ssl_info"]["error"] = str(e)

    def check_headers(self):
        try:
            response = self.session.get(self.target_url, verify=False, timeout=10)
            self.results["headers"] = dict(response.headers)
        except requests.exceptions.RequestException as e:
            self.results["headers"]["error"] = str(e)

    def detect_technologies(self):
        try:
            wappalyzer = Wappalyzer.latest()
            webpage = WebPage.new_from_url(self.target_url)
            detected_tech = wappalyzer.analyze(webpage)
            self.results["technologies"] = list(detected_tech)
        except Exception as e:
            self.results["technologies"].append(f"Error: {str(e)}")

    def scan_ports(self):
        try:
            nm = nmap.PortScanner()
            nm.scan(self.domain, arguments='-p 1-1000 -sV --version-intensity 3')
            for host in nm.all_hosts():
                for proto in nm[host].all_protocols():
                    lport = nm[host][proto].keys()
                    for port in lport:
                        self.results["open_ports"].append({
                            "port": port,
                            "state": nm[host][proto][port]['state'],
                            "service": nm[host][proto][port]['name'],
                            "version": nm[host][proto][port]['version']
                        })
        except Exception as e:
            self.results["open_ports"].append(f"Error: {str(e)}")

    def check_common_vulnerabilities(self):
        self.check_xss()
        self.check_sql_injection()

    def check_xss(self):
        payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]
        vulnerable_params = []
        
        try:
            response = self.session.get(self.target_url, verify=False, timeout=10)
            parsed = urlparse(response.url)
            params = parse_qs(parsed.query)
            
            for param in params:
                for payload in payloads:
                    test_url = self.target_url.replace(f"{param}={params[param][0]}", f"{param}={payload}")
                    try:
                        r = self.session.get(test_url, verify=False, timeout=5)
                        if payload in r.text:
                            vulnerable_params.append(param)
                            break
                    except:
                        pass
            
            if vulnerable_params:
                self.results["vulnerabilities"].append({
                    "type": "xss",
                    "details": f"Posible XSS en parámetros: {', '.join(vulnerable_params)}",
                    "impact": "Los ataques XSS permiten a los atacantes inyectar scripts maliciosos en páginas vistas por otros usuarios.",
                    "exploitation": "Un atacante podría robar cookies, sesiones u otros datos sensibles de los usuarios."
                })
        except Exception as e:
            self.results["vulnerabilities"].append({"type": "error", "details": f"Error al verificar XSS: {str(e)}"})

    def check_sql_injection(self):
        payloads = ["'", "1 OR 1=1", "' OR '1'='1"]
        vulnerable_params = []
        
        try:
            response = self.session.get(self.target_url, verify=False, timeout=10)
            parsed = urlparse(response.url)
            params = parse_qs(parsed.query)
            
            for param in params:
                for payload in payloads:
                    test_url = self.target_url.replace(f"{param}={params[param][0]}", f"{param}={payload}")
                    try:
                        r = self.session.get(test_url, verify=False, timeout=5)
                        if "sql syntax" in r.text.lower() or "mysql_fetch" in r.text.lower():
                            vulnerable_params.append(param)
                            break
                    except:
                        pass
            
            if vulnerable_params:
                self.results["vulnerabilities"].append({
                    "type": "sql_injection",
                    "details": f"Posible SQL Injection en parámetros: {', '.join(vulnerable_params)}",
                    "impact": "Las inyecciones SQL permiten a los atacantes ejecutar comandos SQL arbitrarios en la base de datos.",
                    "exploitation": "Un atacante podría obtener, modificar o eliminar datos de la base de datos."
                })
        except Exception as e:
            self.results["vulnerabilities"].append({"type": "error", "details": f"Error al verificar SQL Injection: {str(e)}"})

    def find_sensitive_files(self):
        sensitive_files = ['/robots.txt', '/sitemap.xml', '/.env', '/.git/config', '/wp-config.php', '/phpinfo.php']
        for file in sensitive_files:
            try:
                url = urljoin(self.target_url, file)
                response = self.session.get(url, verify=False, timeout=5)
                if response.status_code == 200:
                    self.results["sensitive_files"].append(url)
            except:
                pass

    def discover_subdomains(self):
        subdomains = [f"www.{self.domain}", f"mail.{self.domain}", f"ftp.{self.domain}", f"admin.{self.domain}", f"blog.{self.domain}"]
        for subdomain in subdomains:
            try:
                ip = socket.gethostbyname(subdomain)
                self.results["subdomains"].append(subdomain)
            except:
                pass

    def get_shodan_info(self):
        print("Obteniendo información detallada de Shodan...")
        try:
            # Obtener información del host desde Shodan
            results = self.shodan_api.host(self.results["domain_info"]["ip"])
            self.results["shodan_info"] = {
                "os": results.get("os", "Unknown"),
                "ports": results.get("ports", []),
                "vulns": results.get("vulns", []),
                "last_update": results.get("last_update", "Unknown"),
                "country_name": results.get("country_name", "Unknown"),
                "org": results.get("org", "Unknown"),
                "isp": results.get("isp", "Unknown"),
                "asn": results.get("asn", "Unknown"),
                "hostnames": results.get("hostnames", []),
                "domains": results.get("domains", []),
                "services": []
            }
            
            # Obtener información detallada de los servicios en puertos abiertos
            for item in results.get('data', []):
                port_info = {
                    "port": item.get("port"),
                    "product": item.get("product", "Unknown"),
                    "version": item.get("version", "Unknown"),
                    "cpe": item.get("cpe", []),
                    "banner": item.get("data", "No banner"),
                    "vulns": item.get("vulns", [])
                }
                self.results["shodan_info"]["services"].append(port_info)
            
            # Buscar exploits relacionados
            self.get_related_exploits()
                
        except shodan.APIError as e:
            self.results["shodan_info"]["error"] = f"Error de Shodan API: {str(e)}"
        except Exception as e:
            self.results["shodan_info"]["error"] = f"Error general: {str(e)}"

    def get_related_exploits(self):
        try:
            # Buscar exploits relacionados con el dominio
            exploits = self.shodan_api.exploits.search(self.domain)
            self.results["shodan_info"]["related_exploits"] = [
                {
                    "description": exploit.get("description"),
                    "platform": exploit.get("platform"),
                    "port": exploit.get("port"),
                    "cve": exploit.get("cve", [])
                } for exploit in exploits.get("matches", [])[:5]  # Limitamos a 5 exploits
            ]
        except shodan.APIError as e:
            self.results["shodan_info"]["related_exploits"] = f"Error de Shodan API: {str(e)}"
        except Exception as e:
            self.results["shodan_info"]["related_exploits"] = f"Error general: {str(e)}"

    def get_wayback_urls(self):
        print("Obteniendo URLs históricas desde Wayback Machine...")
        try:
            url = f"http://web.archive.org/cdx/search/cdx?url={self.domain}/*&output=json&collapse=urlkey"
            response = requests.get(url)
            data = response.json()
            self.results["wayback_urls"] = [item[2] for item in data[1:]][:20]  # Limitamos a 20 URLs
        except Exception as e:
            self.results["wayback_urls"].append(f"Error: {str(e)}")

    def analyze_results(self):
        print("Analizando resultados...")
        general_info = {
            "report": "Reporte de Análisis de Vulnerabilidades",
            "target_url": self.target_url,
            "timestamp": time.ctime(),
            "recommendations": [
                "Mantener todos los sistemas y software actualizados.",
                "Implementar prácticas de desarrollo seguro.",
                "Realizar pruebas de seguridad periódicas.",
                "Monitorear y revisar los logs del servidor regularmente."
            ]
        }
        self.results["general_info"] = general_info

        if self.results["sensitive_files"]:
            self.results["vulnerabilities"].append({
                "type": "sensitive_files_exposed",
                "details": "Se encontraron archivos sensibles expuestos. Recomendación: Restringir el acceso a estos archivos.",
                "impact": "Estos archivos pueden revelar información crítica sobre la estructura del sitio y potenciales configuraciones sensibles.",
                "exploitation": "Un atacante puede utilizar esta información para planificar ataques más específicos o acceder a datos confidenciales."
            })
        
        if "Strict-Transport-Security" not in self.results["headers"]:
            self.results["vulnerabilities"].append({
                "type": "missing_hsts",
                "details": "Falta el encabezado HSTS. Recomendación: Implementar HSTS para mejorar la seguridad.",
                "impact": "Sin HSTS, los usuarios pueden ser vulnerables a ataques de hombre en el medio (MITM) al ser redirigidos a versiones HTTP inseguras del sitio.",
                "exploitation": "Un atacante puede interceptar y modificar el tráfico entre el usuario y el servidor."
            })

        for tech in self.results["technologies"]:
            if isinstance(tech, dict) and "version" in tech:
                self.results["vulnerabilities"].append({
                    "type": "outdated_software",
                    "details": f"Versión potencialmente desactualizada de {tech['name']}: {tech['version']}.",
                    "impact": "El software desactualizado puede tener vulnerabilidades conocidas que no se han parcheado.",
                    "exploitation": "Un atacante puede explotar estas vulnerabilidades conocidas para comprometer el sistema."
                })

        if not self.results["vulnerabilities"]:
            self.results["vulnerabilities"].append({
                "type": "none",
                "details": "No se encontraron vulnerabilidades específicas en este escaneo. Recomendación: Continuar con las buenas prácticas de seguridad y realizar pruebas periódicas."
            })

    def print_results(self):
        print("\n--- Resultados del Escaneo ---\n")
        print(json.dumps(self.results, indent=4))

if __name__ == '__main__':
    target_url = 'http://example.com'
    shodan_api_key = ''
    scanner = AdvancedWebVulnerabilityScanner(target_url, shodan_api_key)
    scanner.run_scan()
